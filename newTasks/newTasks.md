### Массивы  + объекты

1. **Функция:** Напишите функцию, которая принимает массив чисел и возвращает новый массив, где каждое число заменено на его факториал.
   
   ```javascript
   const arr = [1, 2, 3, 4];
   const result = factorialArray(arr);
   // Ожидаемый результат: [1, 2, 6, 24]
   ```

2. **Функция:** Напишите функцию, которая принимает массив строк и возвращает новый массив, где строки отсортированы по количеству гласных в каждой строке.
   **Пример для проверки:**
   
   ```javascript
   const arr = ['apple', 'banana', 'kiwi', 'grape'];
   const result = sortByVowels(arr);
   // Ожидаемый результат: ['kiwi', 'grape', 'apple', 'banana']
   ```

3. **Функция:** Напишите функцию, которая принимает массив объектов и возвращает новый массив объектов, где добавлено новое свойство 'length', содержащее длину строки из другого свойства.
   **Пример для проверки:**
   
   ```javascript
   const arr = [{ name: 'apple' }, { name: 'banana' }, { name: 'kiwi' }];
   const result = addLengthProperty(arr, 'name');
   // Ожидаемый результат: [{ name: 'apple', length: 5 }, { name: 'banana', length: 6 }, { name: 'kiwi', length: 4 }]
   ```

4. **Функция:** Напишите функцию, которая принимает массив чисел и возвращает объект, где ключи - это числа, а значения - количество их вхождений в массив.
   **Пример для проверки:**
   
   ```javascript
   const arr = [1, 1, 2, 3, 3, 3];
   const result = countOccurrences(arr);
   // Ожидаемый результат: {1: 2, 2: 1, 3: 3}
   ```

5. **Функция:** Напишите функцию, которая принимает массив объектов и возвращает новый массив, содержащий только те объекты, у которых значение определенного свойства больше заданного числа.
   **Пример для проверки:**
   
   ```javascript
   const arr = [{ age: 10 }, { age: 20 }, { age: 30 }];
   const result = filterByPropertyValue(arr, 'age', 15);
   // Ожидаемый результат: [{ age: 20 }, { age: 30 }]
   ```

6. **Функция:** Напишите функцию, которая принимает массив объектов и возвращает массив уникальных значений определенного свойства.
   **Пример для проверки:**
   
   ```javascript
   const arr = [{ type: 'fruit' }, { type: 'vegetable' }, { type: 'fruit' }];
   const result = getUniquePropertyValues(arr, 'type');
   // Ожидаемый результат: ['fruit', 'vegetable']
   ```

7. **Функция:** Напишите функцию, которая принимает массив строк и возвращает новый массив, где строки отсортированы по длине.
   **Пример для проверки:**
   
   ```javascript
   const arr = ['apple', 'banana', 'kiwi'];
   const result = sortByLength(arr);
   // Ожидаемый результат: ['kiwi', 'apple', 'banana']
   ```

8. **Функция:** Напишите функцию, которая принимает массив чисел и возвращает новый массив, где каждое число заменено на сумму всех предыдущих чисел в массиве.
   **Пример для проверки:**
   
   ```javascript
   const arr = [1, 2, 3, 4];
   const result = cumulativeSum(arr);
   // Ожидаемый результат: [1, 3, 6, 10]
   ```

9. **Функция:** Напишите функцию, которая принимает массив объектов и возвращает новый массив объектов, отсортированный по значению определенного свойства в убывающем порядке.
   **Пример для проверки:**
   
   ```javascript
   const arr = [{ score: 10 }, { score: 20 }, { score: 5 }];
   const result = sortByPropertyDesc(arr, 'score');
   // Ожидаемый результат: [{ score: 20 }, { score: 10 }, { score: 5 }]
   ```

10. **Функция:** Напишите функцию, которая принимает массив объектов и возвращает новый объект, где ключи - это значения одного свойства, а значения - массивы объектов, сгруппированные по этому свойству.
    **Пример для проверки:**
    
    ```javascript
    const arr = [{ category: 'fruit', name: 'apple' }, { category: 'vegetable', name: 'carrot' }, { category: 'fruit', name: 'banana' }];
    const result = groupBy(arr, 'category');
    // Ожидаемый результат: { fruit: [{ category: 'fruit', name: 'apple' }, { category: 'fruit', name: 'banana' }], vegetable: [{ category: 'vegetable', name: 'carrot' }] }
    ```

Эти задачи помогут вам улучшить навыки работы с массивами и объектами, и углубить понимание сложных операций над ними.

### Объекты

1. **Функция:** Напишите функцию, которая принимает объект и массив ключей, и возвращает новый объект, содержащий только те пары ключ-значение, где ключи есть в массиве.
   **Пример для проверки:**
   
   ```javascript
   const obj = { a: 1, b: 2, c: 3 };
   const keys = ['a', 'c'];
   const result = filterKeys(obj, keys);
   // Ожидаемый результат: { a: 1, c: 3 }
   ```

2. **Функция:** Напишите функцию, которая принимает объект и преобразует его в массив объектов вида { key: ключ, value: значение }.
   **Пример для проверки:**
   
   ```javascript
   const obj = { a: 1, b: 2, c: 3 };
   const result = toArrayOfObjects(obj);
   // Ожидаемый результат: [ { key: 'a', value: 1 }, { key: 'b', value: 2 }, { key: 'c', value: 3 } ]
   ```

3. **Функция:** Напишите функцию, которая принимает массив объектов и возвращает объект, где ключи - это значения одного свойства, а значения - массивы объектов, сгруппированные по этому свойству.
   **Пример для проверки:**
   
   ```javascript
   const arr = [ { type: 'fruit', name: 'apple' }, { type: 'vegetable', name: 'carrot' }, { type: 'fruit', name: 'banana' } ];
   const result = groupByProperty(arr, 'type');
   // Ожидаемый результат: { fruit: [ { type: 'fruit', name: 'apple' }, { type: 'fruit', name: 'banana' } ], vegetable: [ { type: 'vegetable', name: 'carrot' } ] }
   ```

4. **Функция:** Напишите функцию, которая принимает объект и возвращает новый объект, где ключи и значения поменяны местами.
   **Пример для проверки:**
   
   ```javascript
   const obj = { a: 1, b: 2, c: 3 };
   const result = invertObject(obj);
   // Ожидаемый результат: { 1: 'a', 2: 'b', 3: 'c' }
   ```

5. **Функция:** Напишите функцию, которая принимает объект и возвращает новый объект, где каждое значение увеличено на 1, если оно является числом.
   **Пример для проверки:**
   
   ```javascript
   const obj = { a: 1, b: 'string', c: 3 };
   const result = incrementNumbers(obj);
   // Ожидаемый результат: { a: 2, b: 'string', c: 4 }
   ```

6. **Функция:** Напишите функцию, которая принимает массив объектов и возвращает новый массив объектов, где добавлено новое свойство, вычисленное на основе существующих свойств.
   **Пример для проверки:**
   
   ```javascript
   const arr = [ { width: 10, height: 20 }, { width: 5, height: 5 } ];
   const result = addAreaProperty(arr);
   // Ожидаемый результат: [ { width: 10, height: 20, area: 200 }, { width: 5, height: 5, area: 25 } ]
   ```

7. **Функция:** Напишите функцию, которая принимает объект и возвращает массив всех уникальных значений его свойств.
   **Пример для проверки:**
   
   ```javascript
   const obj = { a: 1, b: 2, c: 1, d: 3 };
   const result = getUniqueValues(obj);
   // Ожидаемый результат: [ 1, 2, 3 ]
   ```

8. **Функция:** Напишите функцию, которая принимает объект и возвращает новый объект, где значения всех строковых свойств преобразованы в верхний регистр.
   **Пример для проверки:**
   
   ```javascript
   const obj = { a: 'hello', b: 'world', c: 3 };
   const result = uppercaseStrings(obj);
   // Ожидаемый результат: { a: 'HELLO', b: 'WORLD', c: 3 }
   ```

9. **Функция:** Напишите функцию, которая принимает объект и массив ключей, и возвращает новый объект без ключей из массива.
   **Пример для проверки:**
   
   ```javascript
   const obj = { a: 1, b: 2, c: 3 };
   const keys = ['a', 'c'];
   const result = omitKeys(obj, keys);
   // Ожидаемый результат: { b: 2 }
   ```

10. **Функция:** Напишите функцию, которая принимает массив объектов и возвращает объект, где ключи - это значения одного свойства, а значения - количество объектов с этим значением свойства.
    **Пример для проверки:**
    
    ```javascript
    const arr = [ { type: 'fruit' }, { type: 'vegetable' }, { type: 'fruit' } ];
    const result = countByProperty(arr, 'type');
    // Ожидаемый результат: { fruit: 2, vegetable: 1 }
    ```

11. **Функция:** Напишите функцию, которая принимает объект и возвращает массив ключей, значения которых являются массивами, содержащими более 3 элементов.
    **Пример для проверки:**
    
    ```javascript
    const obj = { a: [1, 2, 3], b: [1, 2, 3, 4], c: 'not an array' };
    const result = keysWithLongArrays(obj);
    // Ожидаемый результат: [ 'b' ]
    ```

12. **Функция:** Напишите функцию, которая принимает объект и возвращает новый объект, где все числовые значения округлены до ближайшего целого числа.
    **Пример для проверки:**
    
    ```javascript
    const obj = { a: 1.1, b: 2.5, c: 'string' };
    const result = roundNumbers(obj);
    // Ожидаемый результат: { a: 1, b: 3, c: 'string' }
    ```

13. **Функция:** Напишите функцию, которая принимает объект и возвращает новый объект, где все свойства, значения которых являются пустыми строками, удалены.
    **Пример для проверки:**
    
    ```javascript
    const obj = { a: '', b: 'hello', c: 'world', d: '' };
    const result = removeEmptyStrings(obj);
    // Ожидаемый результат: { b: 'hello', c: 'world' }
    ```

14. **Функция:** Напишите функцию, которая принимает объект и возвращает новый объект, где все значения, являющиеся объектами, преобразованы в JSON строки.
    **Пример для проверки:**
    
    ```javascript
    const obj = { a: { nested: 'object' }, b: 'string' };
    const result = stringifyObjects(obj);
    // Ожидаемый результат: { a: '{"nested":"object"}', b: 'string' }
    ```

15. **Функция:** Напишите функцию, которая принимает объект и массив ключей, и возвращает новый объект, где значения для указанных ключей заменены на 'REDACTED'.
    **Пример для проверки:**
    
    ```javascript
    const obj = { a: 1, b: 2, c: 3 };
    const keys = ['b', 'c'];
    const result = redactKeys(obj, keys);
    // Ожидаемый результат: { a: 1, b: 'REDACTED', c: 'REDACTED' }
    ```

16. **Функция:** Напишите функцию, которая принимает объект и возвращает новый объект, где все свойства с числовыми значениями умножены на 2.
    **Пример для проверки:**
    
    ```javascript
    const obj = { a: 1, b: 'string', c: 3 };
    const result = doubleNumbers(obj);
    // Ожидаемый результат: { a: 2, b: 'string', c: 6 }
    ```

17. **Функция:** Напишите функцию, которая принимает массив объектов и возвращает новый объект, содержащий только уникальные значения определенного свойства.
    **Пример для проверки:**
    
    ```javascript
    const arr = [ { type: 'fruit', name: 'apple' }, { type: 'fruit', name: 'banana' }, { type: 'vegetable', name: 'carrot' } ];
    const result = getUniquePropertyValues(arr, 'type');
    // Ожидаемый результат: { type: [ 'fruit', 'vegetable' ] }
    ```

18. **Функция:** Напишите функцию, которая принимает объект и возвращает массив значений всех свойств, значения которых являются функциями.
    **Пример для проверки:**
    
    ```javascript
    const obj = { a: 1, b: () => 'hello', c: 'string', d: () => 'world' };
    const result = getFunctionValues(obj);
    // Ожидаемый результат: [ () => 'hello', () => 'world'
    ```

### Промисы/Сетевые запросы

1. Напишите функцию, которая делает GET запрос на https://jsonplaceholder.typicode.com/posts и выводит массив, в котором есть только заголовки постов.
2. Напишите функцию, которая делает GET запрос на https://jsonplaceholder.typicode.com/users и возвращает массив имен пользователей.
3. Напишите функцию, которая делает GET запрос на https://jsonplaceholder.typicode.com/comments и возвращает массив объектов, содержащих комментарии длиной больше 100 символов.
4. Напишите функцию, которая делает POST запрос на https://jsonplaceholder.typicode.com/posts с телом {title: 'foo', body: 'bar', userId: 1} и выводит ответ.
5. Напишите функцию, которая делает PUT запрос на https://jsonplaceholder.typicode.com/posts/1 с телом {id: 1, title: 'foo', body: 'bar', userId: 1} и выводит ответ.
6. Напишите функцию, которая делает DELETE запрос на https://jsonplaceholder.typicode.com/posts/1 и выводит ответ.
7. Напишите функцию, которая делает GET запрос на https://jsonplaceholder.typicode.com/todos и возвращает массив объектов, где completed = true.
8. Напишите функцию, которая делает GET запрос на https://jsonplaceholder.typicode.com/photos и возвращает массив URL всех фото.
9. Напишите функцию, которая делает GET запрос на https://jsonplaceholder.typicode.com/albums и возвращает массив объектов, где userId = 1.
10. Напишите функцию, которая делает GET запрос на https://jsonplaceholder.typicode.com/users/1 и возвращает объект, содержащий имя пользователя и его компанию.

### DOM манипуляции и CSS

1. Напишите функцию, которая изменяет текст всех элементов с классом 'title' на 'New Title'.
2. Напишите функцию, которая добавляет класс 'active' к элементу с id 'menu'.
3. Напишите функцию, которая изменяет цвет фона всех параграфов на синий.
4. Напишите функцию, которая добавляет новый элемент списка с текстом 'New Item' в конец списка с id 'list'.
5. Напишите функцию, которая удаляет последний элемент списка с id 'list'.
6. Напишите функцию, которая скрывает все изображения на странице.
7. Напишите функцию, которая показывает все скрытые изображения на странице.
8. Напишите функцию, которая увеличивает размер шрифта всех заголовков (h1, h2, и т.д.) на 2 пикселя.
9. Напишите функцию, которая добавляет текст 'Hello, World!' в начало документа.
10. Напишите функцию, которая изменяет атрибут href всех ссылок на 'https://www.example.com'.

### Объектно-ориентированное программирование (ООП)

1. **Задача:** Создайте класс `Person`, который имеет свойства `name` и `age`. Добавьте метод `greet`, который выводит приветствие с именем.
   **Пример для проверки:**
   
   ```javascript
   const person = new Person('Alice', 30);
   const result = person.greet();
   // Ожидаемый результат: "Hello, my name is Alice."
   ```

2. **Задача:** Создайте класс `Rectangle` с полями `width` и `height`. Добавьте метод `getArea`, который возвращает площадь прямоугольника.
   **Пример для проверки:**
   
   ```javascript
   const rect = new Rectangle(10, 5);
   const result = rect.getArea();
   // Ожидаемый результат: 50
   ```

3. **Задача:** Создайте класс `Circle` с полем `radius`. Добавьте метод `getCircumference`, который возвращает длину окружности.
   **Пример для проверки:**
   
   ```javascript
   const circle = new Circle(7);
   const result = circle.getCircumference();
   // Ожидаемый результат: 43.98 (примерно)
   ```

4. **Задача:** Создайте класс `Animal` с полями `name` и `species`. Создайте подкласс `Dog`, который наследует класс `Animal` и добавляет метод `bark`.
   **Пример для проверки:**
   
   ```javascript
   const dog = new Dog('Buddy', 'Canine');
   const result = dog.bark();
   // Ожидаемый результат: "Woof!"
   ```

5. **Задача:** Создайте класс `Vehicle` с полями `make` и `model`. Создайте подкласс `Car`, который наследует класс `Vehicle` и добавляет поле `year`.
   **Пример для проверки:**
   
   ```javascript
   const car = new Car('Toyota', 'Camry', 2020);
   const result = car.model;
   // Ожидаемый результат: "Camry"
   ```

6. **Задача:** Создайте класс `User` с полями `username` и `password`. Добавьте метод `validatePassword`, который принимает строку и возвращает `true`, если она совпадает с паролем пользователя.
   **Пример для проверки:**
   
   ```javascript
   const user = new User('john_doe', 'password123');
   const result = user.validatePassword('password123');
   // Ожидаемый результат: true
   ```

7. **Задача:** Создайте класс `Library` с полем `books` (массив объектов книг). Добавьте методы `addBook` и `findBookByTitle`.
   **Пример для проверки:**
   
   ```javascript
   const library = new Library();
   library.addBook({ title: '1984', author: 'George Orwell' });
   const result = library.findBookByTitle('1984');
   // Ожидаемый результат: { title: '1984', author: 'George Orwell' }
   ```

8. **Задача:** Создайте класс `BankAccount` с полями `accountNumber` и `balance`. Добавьте методы `deposit` и `withdraw`.
   **Пример для проверки:**
   
   ```javascript
   const account = new BankAccount(12345678, 1000);
   account.deposit(500);
   const result = account.balance;
   // Ожидаемый результат: 1500
   ```

9. **Задача:** Создайте класс `Employee` с полями `name` и `salary`. Создайте подкласс `Manager`, который наследует класс `Employee` и добавляет поле `department`.
   **Пример для проверки:**
   
   ```javascript
   const manager = new Manager('Alice', 75000, 'HR');
   const result = manager.department;
   // Ожидаемый результат: "HR"
   ```

10. **Задача:** Создайте класс `Course` с полями `title` и `students` (массив объектов студентов). Добавьте методы `addStudent` и `getStudentByName`.
    **Пример для проверки:**
    
    ```javascript
    const course = new Course('Mathematics');
    course.addStudent({ name: 'John', age: 20 });
    const result = course.getStudentByName('John');
    // Ожидаемый результат: { name: 'John', age: 20 }
    ```

### Задача 1: Система управления университетом

**Задача:** Создайте систему управления университетом, которая включает следующие классы:

1. **Person**: базовый класс с полями `name` и `age`. Метод `getDetails`, который возвращает строку с информацией о человеке.
2. **Student**: класс, наследующий `Person`, с дополнительным полем `studentId`. Метод `getDetails` должен быть переопределен для включения `studentId`.
3. **Teacher**: класс, наследующий `Person`, с дополнительным полем `subject`. Метод `getDetails` должен быть переопределен для включения `subject`.
4. **Course**: класс с полями `title` и `students` (массив объектов студентов). Методы `addStudent` и `getStudentList`.

**Пример для проверки:**

```javascript
const student1 = new Student('John Doe', 20, 'S12345');
const student2 = new Student('Jane Smith', 22, 'S67890');
const teacher = new Teacher('Dr. Brown', 45, 'Mathematics');

const course = new Course('Algebra');
course.addStudent(student1);
course.addStudent(student2);

const result1 = student1.getDetails();
// Ожидаемый результат: "Name: John Doe, Age: 20, Student ID: S12345"

const result2 = teacher.getDetails();
// Ожидаемый результат: "Name: Dr. Brown, Age: 45, Subject: Mathematics"

const result3 = course.getStudentList();
// Ожидаемый результат: ["John Doe", "Jane Smith"]
```

### Задача 2: Система управления библиотекой

**Задача:** Создайте систему управления библиотекой, которая включает следующие классы:

1. **Book**: класс с полями `title`, `author` и `isbn`. Метод `getDetails`, который возвращает строку с информацией о книге.
2. **Member**: класс с полями `name` и `memberId`. Метод `getDetails`, который возвращает строку с информацией о члене библиотеки.
3. **Library**: класс с полями `books` и `members` (оба массива). Методы `addBook`, `addMember`, `borrowBook` (принимает `isbn` и `memberId`), `returnBook` (принимает `isbn` и `memberId`), `getBorrowedBooks` (возвращает список книг, взятых членами).

**Пример для проверки:**

```javascript
const book1 = new Book('1984', 'George Orwell', '1234567890');
const book2 = new Book('To Kill a Mockingbird', 'Harper Lee', '0987654321');

const member1 = new Member('Alice', 'M123');
const member2 = new Member('Bob', 'M456');

const library = new Library();
library.addBook(book1);
library.addBook(book2);
library.addMember(member1);
library.addMember(member2);

library.borrowBook('1234567890', 'M123');

const result1 = book1.getDetails();
// Ожидаемый результат: { "Title: 1984, Author: George Orwell, ISBN: 1234567890" }

const result2 = member1.getDetails();
// Ожидаемый результат: { "Name: Alice, MemberID: M123" }

const result3 = library.getBorrowedBooks();
// Ожидаемый результат: [{ title: '1984', author: 'George Orwell', isbn: '1234567890', borrowedBy: 'M123' }]
const result4 = library.isBorrowed('1234567890');
// Ожидаемый результат: true
const result5 = library.whoBorrowed('1234567890');
// Ожидаемый результат: { name: 'Alice', MemberID: 'M123' }
```

## Структуры данных

### 1. Массив (Array)

**Краткое описание:** Набор элементов, расположенных в памяти последовательно. Доступ к элементам осуществляется по индексам.

**Где применяют и почему:** 

- Используются для хранения множества однотипных данных.

- **Сильные стороны:** 

- Быстрый доступ по индексу.

- Простота использования.

**Слабые стороны:** 

- Неэффективное добавление и удаление элементов, если не с конца.

**Задача:** Реализуйте класс `CustomArray`, который имитирует поведение массива. Добавьте методы `push`, `pop`, `get`.

**Пример для проверки:**

```javascript
const arr = new CustomArray();
arr.push(1);
arr.push(2);
arr.push(3);
const result1 = arr.get(1); // Ожидаемый результат: 2
arr.pop();
const result2 = arr.get(2); // Ожидаемый результат: undefined
```

---

### 2. Связанный список (Linked List)

**Краткое описание:** Набор элементов, называемых узлами, каждый из которых хранит значение и ссылку на следующий узел.

**Где применяют и почему:** 

- Используются, когда необходимо часто вставлять и удалять элементы, особенно в середине списка.
- Хорошо подходят для реализации очередей и стеков.

**Сильные стороны:** 

- Эффективное добавление и удаление элементов.

**Слабые стороны:** 

- Медленный доступ по индексу.

**Задача:** Реализуйте класс `LinkedList` с методами `add`, `remove`, `get`.

**Пример для проверки:**

```javascript
const list = new LinkedList();
list.add(1);
list.add(2);
list.add(3);
const result1 = list.get(1); // Ожидаемый результат: 2
list.remove(2);
const result2 = list.get(2); // Ожидаемый результат: undefined
```

---

### 3. Стек (Stack)

**Краткое описание:** Структура данных, работающая по принципу LIFO (Last In, First Out).

**Где применяют и почему:** 

- Используются для задач, связанных с отменой действий (например, отмена последнего введенного символа).
- Подходят для реализации парсинга и обработки выражений.

**Сильные стороны:** 

- Быстрое добавление и удаление элементов.

**Слабые стороны:** 

- Доступ только к верхнему элементу.

**Задача:** Реализуйте класс `Stack` с методами `push`, `pop`, `peek`.

**Пример для проверки:**

```javascript
const stack = new Stack();
stack.push(1);
stack.push(2);
stack.push(3);
const result1 = stack.pop(); // Ожидаемый результат: 3
const result2 = stack.peek(); // Ожидаемый результат: 2
```

---

### 4. Очередь (Queue)

**Краткое описание:** Структура данных, работающая по принципу FIFO (First In, First Out).

**Где применяют и почему:** 

- Используются для управления потоками данных, например, при печати документов или обработке запросов.

**Сильные стороны:** 

- Эффективное добавление и удаление элементов с концов.

**Слабые стороны:** 

- Доступ только к первому элементу.

**Задача:** Реализуйте класс `Queue` с методами `enqueue`, `dequeue`, `peek`.

**Пример для проверки:**

```javascript
const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
queue.enqueue(3);
const result1 = queue.dequeue(); // Ожидаемый результат: 1
const result2 = queue.peek(); // Ожидаемый результат: 2
```

---

### 5. Хэш-таблица (Hash Table)

**Краткое описание:** Структура данных, реализующая ассоциативный массив, т.е. отображение ключей на значения с использованием хэш-функций.

**Где применяют и почему:** 

- Используются для быстрого поиска, вставки и удаления данных по ключу.

**Сильные стороны:** 

- Очень быстрая операция поиска, вставки и удаления в среднем.

**Слабые стороны:** 

- Возможны коллизии, которые могут замедлить операции.

**Задача:** Реализуйте класс `HashTable` с методами `set`, `get`, `remove`.

**Пример для проверки:**

```javascript
const hashTable = new HashTable();
hashTable.set('name', 'Alice');
hashTable.set('age', 30);
const result1 = hashTable.get('name'); // Ожидаемый результат: 'Alice'
hashTable.remove('name');
const result2 = hashTable.get('name'); // Ожидаемый результат: undefined
```

---

### 6. Дерево (Tree)

**Краткое описание:** Структура данных, состоящая из узлов, где каждый узел имеет ноль или больше дочерних узлов.

**Где применяют и почему:** 

- Используются для представления иерархических данных, например, файловой системы.

**Сильные стороны:** 

- Эффективны для операций поиска и вставки.

**Слабые стороны:** 

- Не всегда эффективны для последовательного доступа.

**Задача:** Реализуйте класс `TreeNode` и `Tree` с методами `add`, `find`.

**Пример для проверки:**

```javascript
const tree = new Tree();
tree.add(5);
tree.add(3);
tree.add(7);
const result1 = tree.find(3); // Ожидаемый результат: TreeNode с значением 3
const result2 = tree.find(10); // Ожидаемый результат: null
```

---

### 7. Граф (Graph)

**Краткое описание:** Структура данных, состоящая из узлов (вершин) и рёбер (связей), соединяющих эти узлы.

**Где применяют и почему:** 

- Используются для моделирования сетей, например, социальных сетей или сетей дорог.

**Сильные стороны:** 

- Гибкость в представлении разнообразных структур.

**Слабые стороны:** 

- Могут быть сложны в реализации и оптимизации.

**Задача:** Реализуйте класс `Graph` с методами `addVertex`, `addEdge`, `removeEdge`.

**Пример для проверки:**

```javascript
const graph = new Graph();
graph.addVertex('A');
graph.addVertex('B');
graph.addEdge('A', 'B');
const result1 = graph.hasEdge('A', 'B'); // Ожидаемый результат: true
graph.removeEdge('A', 'B');
const result2 = graph.hasEdge('A', 'B'); // Ожидаемый результат: false
```

---

### 8. Куча (Heap)

**Краткое описание:** Полностью бинарное дерево, удовлетворяющее свойству кучи, где каждый узел больше (или меньше) своих дочерних узлов.

**Где применяют и почему:** 

- Используются для реализации приоритетных очередей и сортировки (например, пирамидальной сортировки).

**Сильные стороны:** 

- Эффективные операции вставки и извлечения максимального (или минимального) элемента.

**Слабые стороны:** 

- Неэффективны для поиска произвольного элемента.

**Задача:** Реализуйте класс `Heap` с методами `insert`, `extractMax`.

**Пример для проверки:**

```javascript
const heap = new Heap();
heap.insert(10);
heap.insert(20);
heap.insert(5);
const result1 = heap.extractMax(); // Ожидаемый результат: 20
const result2 = heap.extractMax(); // Ожидаемый результат: 10
```

Эти задачи и описания помогут вам лучше понять и применять различные структуры данных в JavaScript.
